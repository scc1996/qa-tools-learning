# 1. 类属性和实例属性的区别
实例属性是指需要实例化一个类之后，实例所使用的变量。实例的些属性是动态的， 不需要在构造函数中,或其它任何地方为它们预先声明或者赋值。

类属性是指类的静态成员变量，在不定义类的实例时，即可以使用，他与类的实例无关。 和c++语言中的static声明的成员变量类似。 例如:
```
class Book:
    index = 10   #类属性

print(Book.index)
Book.index += 1
print(Book.index)

b = Book()
b.name = "Openwrt" #实例属性
```

类属性可以通过类名来访问，实例属性通过实例来访问。如果实例中没有同名的实例属性， 也可以通过实例来读取类属性。 如果类属性需要修改的话，只能通过类名来访问。

# 2.静态方法、类方法和成员方法有什么区别
静态方法,主要处理与这个类的逻辑关联，和c++中的静态方法相似。
类方法(@classmethod), 关注于从类中调用方法, 而不是在实例中调用方法, 定义时需要传递cls; 例如下面定义静态方法和类方法：
成员函数: 实例的方法, 只能通过实例进行调用;
```
class Book:
    version = "1.0"

    def __init__(self, name):
        self.name = name

    def fn1(self):
        print("call fn1 %s %s" % (Book.version, self.name));

    #仅在Book名字空间之下
    def fn2():
        print("call fn2 %s" % Book.version);


    @staticmethod
    def fn3():
        print("call fn3 static method %s" % Book.version);


    @classmethod
    def fn4(cls):
        print("call fn4 class method %s %s" % (Book.version, cls.version));


#Book.fn1()     #成员函数在没有对象时不能调用
Book.fn2()
Book.fn3()
Book.fn4()

book = Book("openwrt")
book.fn1()
#book.fn2()     #传递了对象，但实际上函数不需要Book对象
book.fn3()
book.fn4()
```

fn2,fn3,fn4均不能访问实例中的变量name, 均可以通过Book.version来访问version变量。 类方法可以方便的通过cls来引用类对象中的变量。
### fn2 -- 没有传入self，只在Book名字空间下，所以访问不到name，只能访问到version
### fn3 -- 静态方法，不能被类的实例调用，只能通过类调用
### fn4 -- 类方法，类方法的第一个变量必须为cls，传入类

# 3. 什么是装饰器及装饰器函数
这些都是修饰类的方法的装饰器函数，加上@就可以修饰方法。

@classmethod 将修饰的函数重新修改为类方法。函数第一个参数为类cls
@staticmethod 将修饰的函数改为静态方法。不能被类的实例所调用。
@property 修饰方法可以改为一个属性，通过函数访问，但实际调用时和成员变量类似。

装饰器可以在不修改原方法的基础上，新增功能，装饰器内部定义了一个函数，这个内部函数内容 是输出一个语句，并返回本装饰的函数调用结果。装饰器函数仅返回内部函数。
在被装饰的函数上一行之处增加@并紧跟装饰器函数。
### 被装饰的函数调用方法不变，但函数行为已经方法改变，增加了一个输出语句。

# 4. __init__()和__new__()的区别
1.__new__()方法用于创建实例，类实例化之前会首先调用，它是class的方法，是个静态方法。而__init__()方法用户初始化实例，该方法用在实例对象创建后被调用，它是实例对象的方法，用于设置类实例对象的一些初始值。
2.__new__()传入的参数是cls，__init__()方法传入的参数是self
3.如果类中同时出现了__init__()方法和__new__()方法，则先调用__new__()方法后调用__init__()方法。__new__()方法是创建实例的第一步，执行完了需要返回创建的类的实例，否则则报错，无法执行__init__()方法。其中，__init__()方法将不返回任何信息。
4. __new__()创建实例，__init__()初始化实例
5. 一般声明单例的时候，会用到new方法，在new方法中进行判断是否已经存在实例
__new__ 方法重写非常固定，通常如下
```
def __new__(cls):
      return super().__new__(cls)
```


# 5. 什么是Python自省？
python自省可以理解python中对变量或对象自身的解释，因为python的变量类型并不是非常清晰 的，需要通过一些内建的函数来找出其变量类型及其成员函数等。
另外在运行时，变量经过多次传递和赋值也需要通过函数找出其类型及其类型信息。
一句话总结就是，自省关心的是找出对象的内在特征，例如属性等。

自省API包含以下两个：
type(x) 返回变量x的类型， 即x.__class__ 。
dir(T) 对于模块对象，返回模块的属性，对于类对象，返回他的属性和基类属性。dir将输出其成员变量和成员方法列表。

# 6. 断言 assert
通常在测试过程中使用，用在肯定正确的情况下，如果错误则 立即停止执行。
典型的用途是在测试场景，某个返回值必定是正确的，如果错误停止进一步 的测试。或者捕获这个错误异常，记录失败的次数和失败的代码位置等等。

# 7. 继承
```
class student(Person):
    def __init__(self, fname, lname):
        super().__init__(fname, lname) or Person.__init__(self, fname, lname)
```
当您添加 __init__() 函数时，子类将不再继承父的 __init__() 函数。
注释：子的 __init__() 函数会覆盖对父的 __init__() 函数的继承。
如需保持父的 __init__() 函数的继承，请添加对父的 __init__() 函数的调用
如果您在子类中添加一个与父类中的函数同名的方法，则将覆盖父方法的继承。


    
