1. tcp和udp的区别
（1）TCP 是面向连接的协议，UDP 是无连接协议：tcp传输前建立链接（三次握手），udp不需要三次握手
（2）TCP 可靠，UDP 不可靠：tcp超时/丢包重传，upd不会，upd需要应用层协议来保证
（3）TCP 有序，UDP 无序：tcp重排，udp不会重排
（4）TCP 无界，UDP 有界：tcp使用字节流传输，udp发包
（5）TCP 有流量控制（拥塞控制），UDP 没有：tcp有滑动窗口； TCP 协议的流量控制是基于滑窗协议实现的，拥塞控制和流量控制不同，流量控制是点对点的通信量抑制，抑制发送端发送速率，使得接收端来得及接收。
（6）tcp的头部比udp的头部大，TCP 头部需要 20 字节，UDP 头部只要 8 个字节。

2. https加密
（1）与HTTP的差异
HTTP的URL是由“http://”起始与默认使用端口80，而HTTPS的URL则是由“https://”起始与默认使用端口443。
HTTP不是安全的，而且攻击者可以通过监听和中间人攻击等手段，获取网站帐户和敏感信息等。HTTPS的设计可以防止前述攻击，在正确配置时是安全的。
（2）HTTPS的信任基于预先安装在操作系统中的证书颁发机构（CA）。因此，与一个网站之间的HTTPS连线仅在这些情况下可被信任：
浏览器正确地实现了HTTPS且操作系统中安装了正确且受信任的证书颁发机构；
证书颁发机构仅信任合法的网站；
被访问的网站提供了一个有效的证书，也就是说它是一个由操作系统信任的证书颁发机构签发的（大部分浏览器会对无效的证书发出警告）；
该证书正确地验证了被访问的网站（例如，访问https://example.com时收到了签发给example.com而不是其它域名的证书）；
此协议的加密层（SSL/TLS）能够有效地提供认证和高强度的加密。
HTTPS实际上就是HTTP穿上了SSL/TLS的外套，我们都知道HTTP属于应用层的协议，是离程序员比较近的，而SSL（安全套接字）与TLS（运输层安全）都属于运输层协议。
其实SSL与TLS都是上个世纪的产物，最新版本的TLS建立在SSL 3.0协议规范之上。
（3）https传输流程 -- ssl加密
a）三次握手建立链接（三次握手的目的是为了建立tcp链接 -- tcp是传输层协议
b）服务器发送公钥
c）验证证书有效，并生成私钥，使用公钥加密私钥 -- 非对称加密
d）使用公钥加密私钥，使用私钥加密数据，发送给客户端
e）客户端使用公钥解密私钥，使用私钥解密数据，并用私钥加密数据发送给客户端 -- 对称加密
（4）SSL -- tls是ssl的升级，主要目的是使用第三方机构提供的CA证书验证密钥

3. 输入一个地址，加载出页面，经历了什么 -- dns -- dns是应用层协议，和http/https同属于一层
https://developer.aliyun.com/article/842471
（1）解析URL
（2）DNS服务器解析获取IP地址 -- 如果本地的DNS服务器无法查询，则迭代到根域名服务器、根没找到就到顶级域名服务器、权威域名服务器 查询
（3）获取IP地址后三次握手建立tcp连接
（4）如果是https协议，那么三次握手后要先建立tsl链接（即交换密钥，获得共享密钥）
（5）发送http请求，获取数据：TCP连接建立后，浏览器就可以利用HTTP/HTTPS协议向服务器发送请求了。服务器接受到请求，就解析请求头，
如果头部有缓存相关信息如if-none-match与if-modified-since,则验证缓存是否有效，若有效测返回状态码304，若无效则重新返回资源，状态码为200.
（6）关闭tcp链接--四次挥手
（7）浏览器渲染页面

4. CDN -- 内容分发网络
（1）CDN的全称是Content Delivery Network，即内容分发网络。
（2）CND加速主要是加速静态资源，如网站上面上传的图片、媒体，以及引入的一些Js、css等文件。
（3）CND加速需要依靠各个网络节点，例如100台CDN服务器分布在全国范围，从上海访问，会从最近的节点返回资源，这是核心。
（4）CND服务器通过缓存或者主动抓取主服务器的内容来实现资源储备。
（5）原理：
最简单的CDN网络由一个DNS服务器和几台缓存服务器组成：当用户点击网站页面上的内容URL，经过本地DNS系统解析，DNS系统会最终将域名的解析权交给CNAME指向的CDN专用DNS服务器。
CDN的DNS服务器将CDN的全局负载均衡设备IP地址返回用户。
用户向CDN的全局负载均衡设备发起内容URL访问请求。
CDN全局负载均衡设备根据用户IP地址，以及用户请求的内容URL，选择一台用户所属区域的区域负载均衡设备，告诉用户向这台设备发起请求。
区域负载均衡设备会为用户选择一台合适的缓存服务器提供服务，选择的依据包括：根据用户IP地址，判断哪一台服务器距用户最近；
根据用户所请求的URL中携带的内容名称，判断哪一台服务器上有用户所需内容；查询各个服务器当前的负载情况，判断哪一台服务器尚有服务能力。
基于以上这些条件的综合分析之后，区域负载均衡设备会向全局负载均衡设备返回一台缓存服务器的IP地址。全局负载均衡设备把服务器的IP地址返回给用户。
用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。
如果这台缓存服务器上并没有用户想要的内容，而区域均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地。
（6）其他降低请求带宽的方式：图片/视频压缩格式 -- avif/sharpP等

4. cookie和session的区别，有效期区别
cookie与session区别在于：1、对象不同；2、存储数据大小不同；3、生命周期不同；4、存储位置不同；5、数据类型不同；6、安全性不同
（1）cookie数据存放在客户的浏览器（客户端）上，session数据放在服务器上，但是服务端的session的实现对客户端的cookie有依赖关系的；
（2）cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，考虑到安全应当使用session；
（3）session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能。考虑到减轻服务器性能方面，应当使用COOKIE；
（4）单个cookie在客户端的限制是3K，就是说一个站点在客户端存放的COOKIE不能超过3K；
（5）cookie可以在headers里使用set-cookie方式添加
（6）cookie有效时长，默认是session时长，关闭浏览器即失效，但是也可以自己指定失效时间
---session是基于Cookie技术实现，重启浏览器后再次访问原有的连接依然会创建一个新的session，
---因为Cookie在关闭浏览器后就会消失，但是原来服务器的Session还在，只有等到了销毁的时间会自动销毁
---如果浏览器端禁用了Cookie，那么每次访问都会创建一个新的Session，但是我们可以通过服务器端程序重写URL即可，如果页面多连接多，会增加不必要的工作量，
当cookie被禁止时，如何传递sessionid到服务器？
（1）url重写：就是把session id附加在URL路径的后面，附加的方式也有两种，一种是作为URL路径的附加信息，另一种是作为查询字符串附加在URL后面。网络在整个交互过程中始终保持状态，就必须在每个客户端可能请求的路径后面都包含这个session id。缺点就是网页中不能有静态页面，否则就无法完成重写。（相当于get方法）
（2）隐藏表单：将sessionid隐藏在表单中，通过表单传送给服务器，隐藏的session对外是不可见的。（相当于post方法）

5. 域名映射
nginx


6. adb命令
（1）安装：adb install xxx.apk
（2）卸载：adb uninstall package
（3）查看设备所有应用包名：adb shell pm list packages
（4）查看设备：adb devices

7. linux命令（1）查看top10进程（2）杀掉进程（3）查看带有关键字的进程（4）查看日志（5）日志查询关键字
8. 数据库（1）事务的作用（2）建表语句（3）去重关键字或方法（4）having和where的区别（5）两表联查（6）增删改查
9. 网络状态码301、302、404、502
（1）301: Moved Permanently 永久移动。请求的资源已被永久的移动到新 URI，返回信息会包括新的 URI，浏览器会自动定向到新 URI。今后任何新的请求都应使用新的 URI 代替。
（2）302: Found 临时移动，与 301 类似。但资源只是临时被移动。客户端应继续使用原有URI。
（3）304: 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源。
（4）404: Not Found 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面
（5）500: Internal Server Error 服务器内部错误，无法完成请求。
（6）502: Bad Gateway 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应。

10.接口性能：（1）qps和tps是什么（2）响应时间
11.python成员、对象、装饰器、继承
12.tcp/ip协议：
（1）tcp/ip模型：应用层 - 传输层 - 网络层 - 数据链路层 - 物理层
（2）tcp/ip是协议促组，其中应用层常用协议http/https；传输层tcp/udp；网络层ip（ipv4和ipv6）

13. rpc的原理
使用orderService.newInfo("test") 类似的方式调用不同服务的接口，而非使用网络封装请求
定义：在分布式计算，远程过程调用(Remote Procedure Call，缩写为 RPC)是一个计算机通信协议。
该协议允许运行于一台计算机的程序调用另一个地址空间(通常为一个开放网络的一台计算机)的子程序，而程序员就像调用本地程序一样，无需额外地为这个交互作用编程(无需关注细节)。
RPC是一种服务器-客户端(Client/Server)模式，经典实现是一个通过发送请求-接受回应进行信息交互的系统。RPC是一种进程间通信的模式，程序分布在不同的地址空间里。
如果在同一主机里，RPC可以通过不同的虚拟地址空间(即便使用相同的物理地址)进行通讯，而在不同的主机间，则通过不同的物理地址进行交互。许多技术(常常是不兼容)都是基于这种概念而实现的

14. 远程调用框架
一次完整的RPC调用流程（同步调用，异步另说）如下:

1）服务消费方（client）调用以本地调用方式调用服务；
2）client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；打包的过程叫marshaling，序列化，序列化使用的协议可以是xml，json，protobuf（接口描述语言）
3）client stub找到服务地址，并将消息发送到服务端；
4）server stub收到消息后进行解码；
5）server stub根据解码结果调用本地的服务；
6）本地服务执行并将结果返回给server stub；
7）server stub将返回结果打包成消息并发送至消费方；
8）client stub接收到消息，并进行解码；
9）服务消费方得到最终结果。

RPC框架的目标就是要2~8这些步骤都封装起来，让用户对这些细节透明。
常见的开源框架是grpc，阿里的dubbo，腾讯有trpc

服务注册中心：
服务提供者启动后主动向注册中心注册机器ip、port以及提供的服务列表
服务消费者启动时向注册中心获取服务提供方地址列表，可实现软负载均衡和 Failover

实际自己开发的过程中，定义proto，调用protoc生成.pb和.trpc.go文件，文件里包含序列化和反序列化的stub--协议一定要对齐，要不解不出来
然后再定义前端的接口，供前端调用
后端使用的时候，会先注册service，然后使用本地调用的方式调用service，就可以远程调用其他服务的方法了

15. CI/CD流水线关注的指标
（1）平均代码重复
（2）圈复杂度极高风险+高风险(含存量)函数个数
（3）Gometalinter接入后新告警数
（4）啄木鸟敏感信息问题数
（5）荷鲁斯高危组件问题数
总结来说，代码重复率，圈复杂度，代码规范，明文密码的敏感信息，高危组件（比如全量操作），然后还有iOS安装证书，签名，

